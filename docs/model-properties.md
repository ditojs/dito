# Dito.js Model Properties

The properties of the model are described in the static `properties` field,
holding an object in which the keys are the names of each property, and the
values are again objects describing the property.

These property definitions are used for two main purposes:

- When creating [Migrations](./migrations.md) for a given model, the `yarn
  db:create_migration` command uses the property definitions to determine the
  name, type and nature of each database column. This is why some of the
  information in the property schema is only provided for the purpose of
  migrations.
- Objection.js supports [JSON schema validation](http://json-schema.org/)
  through the static `jsonSchema` class field. Dito.js goes a step further, and
  generates a model's JSON schema automatically out of its property definitions.
  While the Dito.js properties schema can be very similar to JSON schema, it is
  streamlined and simplified in a variety of ways that makes working with it a
  bit easier and more suited to also deduct migrations from it.
  See [Differences to JSON schema](#differences-to-json-schema) for a
  description of these differences.

In order to inspect the JSON schema generated by Dito.js out of these property
definitions, set `config.log.schema = true` in `src/config` and start the app.

By default, the following property schema keywords are available. Additional
keywords can be registered with a custom validator, see
[Validator](./validator.md):

| Keyword                    | Description
| -------------------------- | -------------------------------------------------
| `type`: `string`           | The type of the property. Possible values are:<br>`'string'`, `'text'`, `'number'`, `'integer'`, `'boolean'`, `'object'`, `'array'`, `'date'`, `'datetime'` and `'timestamp'`.
| `format`: `string`         | The requried format of the property.<br>Any standard JSON schema formats are supported, such as `'date-time'`, `'email'`, `'hostname'`, `'ipv4'`, `'ipv6'`, `'uri'`. Additional formats can be registered with a custom validator, see [Validator](./validator.md).
| `default`: `any`           | Sets the property's default value.<br>This impacts both validation as well as migrations: For validation unless when using `patch` operations, missing properties are replaced with their default values. In migrations, the `.defaultTo()` method is called for the database column.
| `required`: `boolean`      | Defines if the property is required.<br>This impacts both validation as well as migrations: Validation errors are thrown for missing required properties. In migrations, the `.notNullable()` method is called for the database column.
| `primary`: `boolean`       | Marks the column as the primary key in the database.
| `foreign`: `boolean`       | Defines if the property is a foreign key.<br>Finds the information about the related model in the `relations` definition and adds a reference to the related model table in migrations, by calling the `.references(columnName).inTable(tableName)` method.
| `index`: `boolean`         | Adds an index to the database column in the migrations, by calling the `.index()` method.
| `nullable`: `boolean`      | Marks the column as nullable in the migrations, by calling the `.nullable()` method.
| `unique`: `boolean` &#124; `string` | Adds a unique constraint to the table for the given column in the migrations, by calling the `.unique()` method. If a string is provided, all columns with the same string value for `unique` are grouped together in one unique constraint, by calling `.unique([column1, column2, …])`.
| `unsigned`: `boolean`      | Marks the column for a property of type `'integer'` to be unsigned in the migrations, by calling the `.index()` method.calling the `.unsigned()` method.
| `computed`: `boolean`      | Marks the property as computed.<br>Computed properties are not present as columns in the database itself. They can be created either by an SQL statement (`SELECT … AS`), or by a getter accessor defined on the model. Computed properties are set when converting to JSON if not present already, and removed again before data is sent to the database.
| `hidden`: `boolean`        | Marks the property has hidden, so that it does not show up in data converted to JSON.<br>This can be used for sensitive data.
| `range`: `Array`           | Validates a property of type `'number'` or `'integer'` to be in a given range, e.g.: `[2, 5]` 

In addition to all the declared properties, Dito automatically adds an `id`
property to the properties of every model if a property with the `primary: true`
setting is not already explicitly defined. The settings used for an
automatically inserted primary `id` are:

```js
id: {
  type: 'integer',
  primary: true
}
```

The same is the case if foreign keys occurring in `relations` definitions are
not explicitly defined in the properties. The settings used for automatically
inserted foreign keys are:

```js
foreignKeyId: {
  type: 'integer',
  unsigned: true,
  foreign: true,
  index: true,
  nullable: relation.nullable || false
}
```

Note that in order to avoid having to declare foreign keys just to provide
the desired `nullable` setting, Dito.js allows it to be provided on the relation
instead. See [Model Relations](./model-relations.md) for more information.

## Example

Here is an example class called `MyModel` with a selection of property definitions:

```js
import { Model } from '@ditojs/server'

export class MyModel extends Model {
  static properties = {
    firstName: {
      type: 'string',
      required: true
    },

    lastName: {
      type: 'string',
      required: true
    },

    fullName: {
      type: 'string',
      computed: true
    },

    email: {
      type: 'string',
      format: 'email',
      nullable: true
    },

    age: {
      type: 'integer',
      range: [0, 100],
      required: true
    }
  }

  get fullName() {
    return `${this.firstName} ${this.lastName}`
  }
}
```

To highlight a few details, particularly the validation keywords in the `email`
and `age` property:

- The `format: 'email'` is a standard JSON schema format, supported by the
  [Ajv](https://github.com/epoberezkin/ajv) validation library which Dito.js
  uses for validation.
- The `range: [0, 100]` is a custom keyword that Dito.js adds to its validator
  by default.
- `fullName` is a computed property and therefore has a getter accessor defined
  in the model.

If we activate the app's `config.log.schema` setting and start up the app, we
can see the resulting JSON schema that is used for validation, logged to the
console:

```js
{
  '$id': 'MyModel',
  '$schema': 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    id: {
      type: 'integer',
      primary: true
    },
    firstName: {
      type: 'string',
      format: 'required'
    },
    lastName: {
      type: 'string',
      format: 'required'
    },
    fullName: {
      type: 'string',
      computed: true
    },
    email: {
      oneOf: [{
        type: 'string',
        format: 'email'
      }, {
        type: 'null'
      }],
      nullable: true
    },
    age: {
      type: 'integer',
      range: [0, 100],
      format: 'required'
    },
    createdAt: {
      type: ['string', 'object'],
      format: 'date-time'
    },
    updatedAt: {
      type: ['string', 'object'],
      format: 'date-time'
    }
  },
  additionalProperties: false,
  required: ['firstName', 'lastName', 'age']
}
```

## Differences to JSON schema

Notice the differences to the JSON schema output in the above example:

- Dito.js property definitions only describe the model's properties, while the
  JSON schema describes the whole model, hence the `type: 'object'` wrapper.
- JSON schema does not support the `required: true` keyword on the properties.
  Instead, the required keyword is defined as an array outside of its
  `properties` object. Dito.js adds a custom `format: 'required'` format, to
  perform a more natural `required` check where empty strings are not considered
  to be defined values. JSON schema's `required` check would allow empty strings
  to pass through validation.
- The desired effect of `nullable: true` can only be achieved by rather
  complicated `oneOf: []` statements in JSON schema. Luckily, they don't have to
  be spelled out, as Dito.js expands `nullable: true` statements for us.
- `'date'`, `'datetime'` and `'timestamp'` aren't real JSON schema types, but
  they are useful for Dito.js when creating migrations, so they are supported.
  In the generated JSON schema, they are replaced with `['string', 'object']`,
  both types in which dates can be represented.

## Nested Properties

Through Objection.js' support of JSON properties (JavaScript objects, arrays and
values that are stored in the database as JSON or JSONB), Dito.js has native
support for such properties. The schema for these properties can be described
using standard JSON schema notation with nested JSON schemas per property:

```js
static properties = {
  messages: {
    type: 'array',
    items: {
      type: 'object',
      properties: {
        author: {
          type: 'string'
        },

        content: {
          type: 'string'
        },

        comments: {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      }
    }
  }
}
```

Note that in this JSON schema notation, each property is again a full JSON
schema. But just like with the resulting JSON schema that we've logged in the
[Example](#example) above, these nested JSON schemas tend to get
complex and long-winded fairly quickly. This is why Dito.js offers a few schema
shorthands:

## Differences to Objection.js

- Objection.js doesn't provide any mechanisms to formulate `properties`
  definitions, or automatically create validation schemas and migrations from
  it, nor does it inherit or merge property definitions from parent classes.
